* efi booting 과정

** U-boot (커널 진입 전)
   1. do_bootefi: booting 시작

      u-boot source code ($u-boot/cmd/bootefi.c) 에서 살펴보면,
      `do_bootefi` 라는 이름으로 메모리에서 EFI를 로드할 수 있도록
      명령어를 제공

#+BEGIN_SRC c++
  U_BOOT_CMD(
	  bootefi, 3, 0, do_bootefi,
	  "Boots an EFI payload from memory",
	  bootefi_help_text
  );
#+END_SRC

   2. efi_init_obj_list: boot service 초기화

      watchdog, reset system, initrd, ... 등등
      ($u-boot/lib/efi_loader/efi_setup.c 참고)

   3. do_bootefi_image(argv[1])
      -> efi_run_image(image_buf, size)
      -> do_bootefi_exec(handle, load_options)
      -> efi_start_image 호출

#+BEGIN_SRC c++
  static efi_status_t do_bootefi_exec(efi_handle_t handle, void *load_options)
  {
	  efi_status_t ret;
	  efi_uintn_t exit_data_size = 0;
	  u16 *exit_data = NULL;

	  /* Call our payload! */
	  ret = EFI_CALL(efi_start_image(handle, &exit_data_size, &exit_data));
	  if (ret != EFI_SUCCESS) {
		  log_err("## Application failed, r = %lu\n",
			  ret & ~EFI_ERROR_MASK);
		  if (exit_data) {
			  log_err("## %ls\n", exit_data);
			  efi_free_pool(exit_data);
		  }
	  }

	  efi_restore_gd();

	  free(load_options);

	  return ret;
  }
#+END_SRC


    4. 아래 코드를 통해 EFI_PE entry 부분 실행
       (이 때, efi_system_table은 전부 init된 상태)


#+BEGIN_SRC cpp
  ret = EFI_CALL(image_obj->entry(image_handle, &systab));
#+END_SRC

** Linux Kernel (커널 진입 후)
1. firmware/driver/efi의 stub의 pe_entry에서 image 로딩 주소, fdt등의 정보를 가지고옴
   (이 정보들은 u-boot의 efi에서 다 설정 됨)

2. 이제 위의 정보들을 가지고, efi_enter_kernel을 호출

3. arm64/kernel/efi-entry.S의 efi_enter_kernel를 호출

4. primary_entry_offset => image-vars.h에 efistub으로 정의 되는 변수가 있다, 결국 _text에서 (image의 최초 시작 주소) primary_entry (head.S)까지의 offset이며 x19에 해당 값을 저장해 primary_entry로 점프

5. 이 때, (DTB == FDT)를 x0에 설정하고 콜 함
